import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import Login from '../../pages/Login';
import ResetPassword from '../../pages/ResetPassword';
import authService from '../../services/authService';
import { renderWithProviders } from '../../../testing/testUtils';

// Mock the authService
jest.mock('../../services/authService');

// Mock useSearchParams and useNavigate
const mockSearchParams = new URLSearchParams();
const mockNavigate = jest.fn();

jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useSearchParams: () => [mockSearchParams],
  useNavigate: () => mockNavigate,
}));

describe('Password Reset Security Integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockSearchParams.clear();
  });

  describe('Complete Forgot Password Flow', () => {
    test('handles complete forgot password security flow', async () => {
      // Step 1: User clicks "Forgot Password?" on login page
      authService.resetPassword.mockResolvedValue({
        success: true,
        resetToken: 'secure-token-123',
        resetUrl: 'https://test.com/reset-password?mode=customReset&token=secure-token-123&email=test@example.com'
      });

      render(<Login />, { wrapper: BrowserRouter });

      // Fill in email
      const emailInput = screen.getByPlaceholderText(/Email address/i);
      fireEvent.change(emailInput, { target: { value: 'test@example.com' } });

      // Click forgot password
      const forgotPasswordLink = screen.getByText(/Forgot Password/i);
      fireEvent.click(forgotPasswordLink);

      await waitFor(() => {
        expect(authService.resetPassword).toHaveBeenCalledWith('test@example.com');
        expect(screen.getByText(/Password reset email sent/i)).toBeInTheDocument();
      });

      // Step 2: User follows email link to reset page
      mockSearchParams.set('mode', 'customReset');
      mockSearchParams.set('token', 'secure-token-123');
      mockSearchParams.set('email', 'test@example.com');

      authService.validateCustomResetToken.mockResolvedValue({
        valid: true,
        email: 'test@example.com'
      });

      authService.validatePasswordStrength.mockResolvedValue({
        isValid: true,
        issues: [],
        strength: 'strong'
      });

      authService.completeCustomPasswordReset.mockResolvedValue({
        success: true,
        passwordStrength: 'strong'
      });

      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByText('Reset Your Password')).toBeInTheDocument();
      });

      // Step 3: User enters new password with real-time validation
      const passwordInput = screen.getByLabelText(/New Password/i);
      fireEvent.change(passwordInput, { target: { value: 'NewSecurePassword123!' } });

      await waitFor(() => {
        expect(authService.validatePasswordStrength).toHaveBeenCalledWith('NewSecurePassword123!');
        expect(screen.getByText('Password Strength:')).toBeInTheDocument();
        expect(screen.getByText('strong')).toBeInTheDocument();
      });

      // Step 4: User confirms password and submits
      const confirmPasswordInput = screen.getByLabelText(/Confirm New Password/i);
      fireEvent.change(confirmPasswordInput, { target: { value: 'NewSecurePassword123!' } });

      const submitButton = screen.getByRole('button', { name: /Reset Password/i });
      fireEvent.click(submitButton);

      await waitFor(() => {
        expect(authService.completeCustomPasswordReset).toHaveBeenCalledWith(
          'secure-token-123',
          'test@example.com',
          'NewSecurePassword123!'
        );
        expect(screen.getByText('Password Reset Complete!')).toBeInTheDocument();
      });
    });
  });

  describe('Security Validation Integration', () => {
    beforeEach(() => {
      mockSearchParams.set('mode', 'customReset');
      mockSearchParams.set('token', 'test-token');
      mockSearchParams.set('email', 'test@example.com');

      authService.validateCustomResetToken.mockResolvedValue({
        valid: true,
        email: 'test@example.com'
      });
    });

    test('prevents weak password submission', async () => {
      authService.validatePasswordStrength.mockResolvedValue({
        isValid: false,
        issues: ['Password must be at least 8 characters long', 'Password must contain at least one uppercase letter'],
        strength: 'weak'
      });

      authService.completeCustomPasswordReset.mockRejectedValue(
        new Error('Password requirements not met: Password must be at least 8 characters long, Password must contain at least one uppercase letter')
      );

      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByLabelText(/New Password/i)).toBeInTheDocument();
      });

      // Enter weak password
      const passwordInput = screen.getByLabelText(/New Password/i);
      fireEvent.change(passwordInput, { target: { value: 'weak' } });

      await waitFor(() => {
        expect(screen.getByText('weak')).toBeInTheDocument();
        expect(screen.getByText('Password must be at least 8 characters long')).toBeInTheDocument();
        expect(screen.getByText('Password must contain at least one uppercase letter')).toBeInTheDocument();
      });

      // Try to submit
      const confirmPasswordInput = screen.getByLabelText(/Confirm New Password/i);
      fireEvent.change(confirmPasswordInput, { target: { value: 'weak' } });

      const submitButton = screen.getByRole('button', { name: /Reset Password/i });
      fireEvent.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/Password requirements not met/i)).toBeInTheDocument();
      });
    });

    test('prevents compromised password submission', async () => {
      authService.validatePasswordStrength.mockResolvedValue({
        isValid: true,
        issues: [],
        strength: 'medium'
      });

      authService.completeCustomPasswordReset.mockRejectedValue(
        new Error('This password has been found in 50000 data breaches. Please choose a different password.')
      );

      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByLabelText(/New Password/i)).toBeInTheDocument();
      });

      // Enter compromised password
      const passwordInput = screen.getByLabelText(/New Password/i);
      fireEvent.change(passwordInput, { target: { value: 'Password123!' } });

      const confirmPasswordInput = screen.getByLabelText(/Confirm New Password/i);
      fireEvent.change(confirmPasswordInput, { target: { value: 'Password123!' } });

      const submitButton = screen.getByRole('button', { name: /Reset Password/i });
      fireEvent.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/This password has been found in 50000 data breaches/i)).toBeInTheDocument();
      });
    });

    test('handles rate limiting gracefully', async () => {
      authService.resetPassword.mockRejectedValue(
        new Error('Too many password reset attempts. Please try again in 15 minutes.')
      );

      render(<Login />, { wrapper: BrowserRouter });

      // Fill in email
      const emailInput = screen.getByPlaceholderText(/Email address/i);
      fireEvent.change(emailInput, { target: { value: 'test@example.com' } });

      // Click forgot password multiple times (simulating rate limit)
      const forgotPasswordLink = screen.getByText(/Forgot Password/i);
      fireEvent.click(forgotPasswordLink);

      await waitFor(() => {
        expect(screen.getByText(/Too many password reset attempts/i)).toBeInTheDocument();
      });
    });

    test('handles suspicious email domains', async () => {
      authService.resetPassword.mockRejectedValue(
        new Error('Email domain not allowed.')
      );

      render(<Login />, { wrapper: BrowserRouter });

      // Fill in suspicious email
      const emailInput = screen.getByPlaceholderText(/Email address/i);
      fireEvent.change(emailInput, { target: { value: 'test@suspicious-domain.tk' } });

      const forgotPasswordLink = screen.getByText(/Forgot Password/i);
      fireEvent.click(forgotPasswordLink);

      await waitFor(() => {
        expect(screen.getByText(/Email domain not allowed/i)).toBeInTheDocument();
      });
    });
  });

  describe('Token Security Integration', () => {
    test('handles expired tokens', async () => {
      mockSearchParams.set('mode', 'customReset');
      mockSearchParams.set('token', 'expired-token');
      mockSearchParams.set('email', 'test@example.com');

      authService.validateCustomResetToken.mockResolvedValue({
        valid: false,
        error: 'Reset link has expired'
      });

      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByText('Invalid Reset Link')).toBeInTheDocument();
        expect(screen.getByText(/Reset link has expired/i)).toBeInTheDocument();
      });
    });

    test('handles used tokens', async () => {
      mockSearchParams.set('mode', 'customReset');
      mockSearchParams.set('token', 'used-token');
      mockSearchParams.set('email', 'test@example.com');

      authService.validateCustomResetToken.mockResolvedValue({
        valid: false,
        error: 'Reset link has already been used'
      });

      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByText('Invalid Reset Link')).toBeInTheDocument();
        expect(screen.getByText(/Reset link has already been used/i)).toBeInTheDocument();
      });
    });

    test('handles invalid tokens', async () => {
      mockSearchParams.set('mode', 'customReset');
      mockSearchParams.set('token', 'invalid-token');
      mockSearchParams.set('email', 'test@example.com');

      authService.validateCustomResetToken.mockResolvedValue({
        valid: false,
        error: 'Invalid reset token'
      });

      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByText('Invalid Reset Link')).toBeInTheDocument();
        expect(screen.getByText(/Invalid reset token/i)).toBeInTheDocument();
      });
    });
  });

  describe('User Experience Integration', () => {
    beforeEach(() => {
      mockSearchParams.set('mode', 'customReset');
      mockSearchParams.set('token', 'valid-token');
      mockSearchParams.set('email', 'test@example.com');

      authService.validateCustomResetToken.mockResolvedValue({
        valid: true,
        email: 'test@example.com'
      });
    });

    test('provides real-time password feedback', async () => {
      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByLabelText(/New Password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/New Password/i);

      // Test weak password feedback
      authService.validatePasswordStrength.mockResolvedValue({
        isValid: false,
        issues: ['Password must be at least 8 characters long'],
        strength: 'weak'
      });

      fireEvent.change(passwordInput, { target: { value: '123' } });

      await waitFor(() => {
        expect(screen.getByText('weak')).toBeInTheDocument();
        expect(screen.getByText('Password Requirements:')).toBeInTheDocument();
      });

      // Test strong password feedback
      authService.validatePasswordStrength.mockResolvedValue({
        isValid: true,
        issues: [],
        strength: 'strong'
      });

      fireEvent.change(passwordInput, { target: { value: 'VeryStrongPassword123!' } });

      await waitFor(() => {
        expect(screen.getByText('strong')).toBeInTheDocument();
      });
    });

    test('shows password visibility toggle', async () => {
      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByLabelText(/New Password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/New Password/i);
      expect(passwordInput).toHaveAttribute('type', 'password');

      // Find and click visibility toggle
      const toggleButtons = screen.getAllByRole('button');
      const visibilityToggle = toggleButtons.find(btn => 
        btn.querySelector('[data-testid*="Visibility"]')
      );

      if (visibilityToggle) {
        fireEvent.click(visibilityToggle);
        expect(passwordInput).toHaveAttribute('type', 'text');
      }
    });

    test('validates password confirmation matching', async () => {
      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByLabelText(/New Password/i)).toBeInTheDocument();
      });

      // Enter mismatched passwords
      fireEvent.change(screen.getByLabelText(/New Password/i), {
        target: { value: 'Password123!' }
      });
      fireEvent.change(screen.getByLabelText(/Confirm New Password/i), {
        target: { value: 'DifferentPassword123!' }
      });

      // Submit form
      fireEvent.click(screen.getByRole('button', { name: /Reset Password/i }));

      await waitFor(() => {
        expect(screen.getByText('Passwords do not match')).toBeInTheDocument();
      });
    });
  });

  describe('Error Recovery Integration', () => {
    test('provides helpful error recovery options', async () => {
      mockSearchParams.set('mode', 'customReset');
      mockSearchParams.set('token', 'expired-token');
      mockSearchParams.set('email', 'test@example.com');

      authService.validateCustomResetToken.mockResolvedValue({
        valid: false,
        error: 'Reset link has expired'
      });

      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByText('Invalid Reset Link')).toBeInTheDocument();
        expect(screen.getByRole('button', { name: /Back to Login/i })).toBeInTheDocument();
        expect(screen.getByRole('button', { name: /Request New Reset Link/i })).toBeInTheDocument();
      });

      // Test navigation to login
      fireEvent.click(screen.getByRole('button', { name: /Back to Login/i }));
      expect(mockNavigate).toHaveBeenCalledWith('/login');

      // Test navigation to request new reset
      fireEvent.click(screen.getByRole('button', { name: /Request New Reset Link/i }));
      expect(mockNavigate).toHaveBeenCalledWith('/login', { 
        state: { showForgotPassword: true } 
      });
    });
  });

  describe('Accessibility Integration', () => {
    beforeEach(() => {
      mockSearchParams.set('mode', 'customReset');
      mockSearchParams.set('token', 'valid-token');
      mockSearchParams.set('email', 'test@example.com');

      authService.validateCustomResetToken.mockResolvedValue({
        valid: true,
        email: 'test@example.com'
      });
    });

    test('provides proper ARIA labels and roles', async () => {
      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByRole('textbox', { name: /New Password/i })).toBeInTheDocument();
        expect(screen.getByRole('textbox', { name: /Confirm New Password/i })).toBeInTheDocument();
        expect(screen.getByRole('button', { name: /Reset Password/i })).toBeInTheDocument();
      });
    });

    test('provides screen reader friendly error messages', async () => {
      authService.completeCustomPasswordReset.mockRejectedValue(
        new Error('Password requirements not met: Password must be at least 8 characters long')
      );

      render(<ResetPassword />, { wrapper: BrowserRouter });

      await waitFor(() => {
        expect(screen.getByLabelText(/New Password/i)).toBeInTheDocument();
      });

      // Submit with weak password
      fireEvent.change(screen.getByLabelText(/New Password/i), {
        target: { value: 'weak' }
      });
      fireEvent.change(screen.getByLabelText(/Confirm New Password/i), {
        target: { value: 'weak' }
      });

      fireEvent.click(screen.getByRole('button', { name: /Reset Password/i }));

      await waitFor(() => {
        const errorAlert = screen.getByRole('alert');
        expect(errorAlert).toHaveTextContent(/Password requirements not met/i);
      });
    });
  });
});
